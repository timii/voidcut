<script lang="ts">
	import type { IMedia } from '$lib/interfaces/Media';
	import {
		handleTimelineMediaDrop,
		hasHorizontalScrollbar,
		hasVerticalScrollbar,
		moveTimelineThumb,
		resetAllBeingDragged
	} from '$lib/utils/utils';
	import { onMount } from 'svelte';
	import TimelineRow from './TimelineRow.svelte';
	import TimelineRuler from './TimelineRuler.svelte';
	import TimelineThumb from './TimelineThumb.svelte';
	import {
		currentThumbPosition,
		currentTimelineScale,
		horizontalScroll,
		maxPlaybackTime,
		startAmountOfTicks,
		thumbOffset,
		timelineTracks,
		verticalScroll
	} from '../../../stores/store';
	import type { ITimelineTrack } from '$lib/interfaces/Timeline';
	import TimelineControls from './TimelineControls.svelte';
	import { CONSTS } from '$lib/utils/consts';
	import TimelineRowDivider from './TimelineRowDivider.svelte';

	let hoverElement = false;
	let scrollContainerEl: HTMLDivElement;
	let isOverflowingX = false;
	let isOverflowingY = false;
	let amountOfTicks = 0;
	let amountOfTicksRounded = 0;
	let thumbElementRef: HTMLElement | null = null;

	onMount(() => {
		// listen to selected events in the window
		const events = ['mouseup', 'dragend'];
		events.forEach((e) => {
			window.addEventListener(e, () => {
				// delay resetting the store values to workaround when mouse down event fires after mouse button isn't held down anymore
				setTimeout(() => {
					resetAllBeingDragged();
					console.log(e + ' mouseup');
				}, CONSTS.resetDelay);
			});
		});

		// TODO: change that so check both scrollbars everytime something in the timeline changes and/or screen sitze changes
		isOverflowingY = hasVerticalScrollbar(scrollContainerEl);
		isOverflowingX = hasHorizontalScrollbar(scrollContainerEl);

		// get current width of timeline to calculate max playback time at the start
		amountOfTicks = scrollContainerEl.scrollWidth / $currentTimelineScale;
		amountOfTicksRounded = Math.ceil(amountOfTicks);

		// set amount of ticks at the start
		startAmountOfTicks.set(amountOfTicksRounded);
		console.log(
			'timeline width -> clientWidth:',
			scrollContainerEl.clientWidth,
			'scrollWidth:',
			scrollContainerEl.scrollWidth,
			'offsetWidth:',
			scrollContainerEl.offsetWidth,
			'thumbOffset:',
			$thumbOffset,
			'amount of ticks in the timeline possible:',
			amountOfTicks,
			'rounded up:',
			amountOfTicksRounded
		);
		// TODO: check the timeline width everytime something in the timeline changes

		console.log(
			'onMount -> scrollContainerEl:',
			scrollContainerEl,
			'overflowY?:',
			isOverflowingY,
			'overflowX?:',
			isOverflowingX
		);
	});

	// get the max playback time everytime the timelineTracks store changes
	$: getMaxPlaybackTime($timelineTracks);
	// // call this function every time the timelineTracks store variable changes
	// $: $timelineTracks,
	// 	(() => {
	// 		console.log('Timeline -> timelineTracks changed:', $timelineTracks);
	// 	})();

	function getMaxPlaybackTime(tracks: ITimelineTrack[]) {
		console.log('Timeline -> timelineTracks changed:', $timelineTracks);
		// go through each row and element and check what the last playback time is
		if (tracks.length > 0) {
			let maxTime = 0;
			tracks.forEach((track) => {
				console.log('getMaxPlaybackTime -> track:', track);
				track.elements.forEach((element) => {
					// add element offset and duration to get the time the element ends
					const endTime = element.playbackStartTime + element.duration;
					if (endTime > maxTime) {
						maxTime = endTime;
					}
					console.log('getMaxPlaybackTime -> element:', element, 'endTime:', endTime);
				});
			});
			maxPlaybackTime.set(maxTime);

			// update timeline ruler ticks amount to scale it with the increased timeline width
			// but only if the new amount of ticks is equal or more to the start amount
			const maxTimeAsTicks = Math.ceil(maxTime / CONSTS.secondsMultiplier);
			if (maxTimeAsTicks >= $startAmountOfTicks) {
				console.log('getMaxPlaybackTime in if');
				amountOfTicksRounded = maxTimeAsTicks;
			} else {
				// if the max time is smaller than the starting amount of ticks set it back to the starting value to avoid timeline ruler being short than screen
				amountOfTicksRounded = $startAmountOfTicks;
			}
			console.log(
				'getMaxPlaybackTime -> after all for each maxTime:',
				maxTime,
				'amountOfTicksRounded:',
				amountOfTicksRounded,
				'startAmountOfTicks:',
				$startAmountOfTicks,
				'amountOfTicksRounded >= $startAmountOfTicks:',
				amountOfTicksRounded >= $startAmountOfTicks
			);
		} else {
			// if the array is empty -> reset maxPlaybackTime
			maxPlaybackTime.set(0);
		}
	}

	function onDropElement(e: DragEvent) {
		// prevent default behavior
		e.preventDefault();
		e.stopPropagation();
		hoverElement = false;

		handleAddElementToTimeline(e);
	}

	function onHoverElement(e: DragEvent) {
		// prevent default behavior
		e.preventDefault();
		e.stopPropagation();
		hoverElement = true;

		// const elemBelow = document.elementFromPoint(e.clientX, e.clientY);
		// const elemsBelow = document.elementsFromPoint(e.clientX, e.clientY);
		// console.log(
		// 	'onHoverElement -> e:',
		// 	e,
		// 	'e.clientX/e.clientY',
		// 	e.clientX,
		// 	'/',
		// 	e.clientY,
		// 	'elements:',
		// 	elemsBelow,
		// 	'elementFromPoint',
		// 	elemBelow,
		// 	'closest element:',
		// 	elemBelow?.closest('div')
		// );
	}

	function onHoverOverDivider(e: DragEvent) {
		// prevent default behavior
		e.preventDefault();
		e.stopPropagation();
		(e.target as HTMLDivElement).classList.add('drag-over');
	}

	function onDropOverDivider(e: DragEvent, index: number) {
		// prevent default behavior
		e.preventDefault();
		e.stopPropagation();
		(e.target as HTMLDivElement).classList.remove('drag-over');

		handleAddElementToTimeline(e, index);
	}

	// TODO: add comment
	function handleAddElementToTimeline(e: DragEvent, index?: number) {
		// get data from dropped element
		let mediaDataString = e.dataTransfer?.getData(CONSTS.mediaPoolTransferKey);
		if (!mediaDataString) {
			return;
		}

		// parse it back to be an object again
		const mediaData: IMedia = JSON.parse(mediaDataString);

		// only handle files when actually dropped
		if (mediaData && e.type !== 'dragleave') {
			handleTimelineMediaDrop(mediaData, index);
		}
	}

	// listen to scrolling in the timeline
	function onTimelineScroll(e: Event) {
		if (thumbElementRef === null) {
			thumbElementRef = document.getElementById('timeline-thumb');
		}

		if (e.currentTarget) {
			const target = e.currentTarget as HTMLElement;
			const horizontalScrollValue = target.scrollLeft;
			const verticalScrollValue = target.scrollTop;
			$horizontalScroll = horizontalScrollValue;
			$verticalScroll = verticalScrollValue;

			const thumbBoundingRect = thumbElementRef?.getBoundingClientRect();
			if (!thumbBoundingRect) {
				return;
			}

			// if the thumbs x position is smaller than 0 it is out of the view and we clamp the thumb to the left side
			if (thumbBoundingRect.x < 0) {
				// subtract 16 from the scrol position to have no padding on the left side of the thumb
				currentThumbPosition.set(horizontalScrollValue - 16);
			}

			// if the thumbs x position is bigger than the width of the timeline (- the width of the timeline) we clamp it to the right side
			if (thumbBoundingRect.x > scrollContainerEl.clientWidth - 12) {
				// new thumb position is the amount scrolled + the width of the timeline (- the width of the thumb + left padding)
				currentThumbPosition.set(horizontalScrollValue + scrollContainerEl.clientWidth - 28);
			}
			console.log(
				'timeline scrolled -> e:',
				e,
				'horizontal:',
				horizontalScrollValue,
				'vertical:',
				verticalScrollValue,
				'thumbElementRef:',
				thumbElementRef,
				'thumbBoundingRect:',
				thumbBoundingRect,
				'scrollContainerEl:',
				scrollContainerEl,
				'scrollContainerEl.clientWidth:',
				scrollContainerEl.clientWidth
			);
		}
	}
</script>

<div class="flex flex-col h-full gap-2 timeline-container">
	<!-- Timeline Controls -->
	<TimelineControls></TimelineControls>

	<!-- Timeline Scroll Container -->
	<div
		class="flex flex-col w-full h-full gap-1 overflow-x-scroll overflow-y-scroll timeline-scroll-container"
		id="timeline-scroll-container"
		on:drop={onDropElement}
		on:dragleave={onDropElement}
		on:dragenter={onHoverElement}
		on:dragover={onHoverElement}
		on:pointermove={moveTimelineThumb}
		on:mousedown={moveTimelineThumb}
		on:scroll={onTimelineScroll}
		style="background-color: {hoverElement ? '#2e2e35' : ''};"
		bind:this={scrollContainerEl}
	>
		<!-- Timeline Content -->
		<!-- calculate width dynamically and fix width if element overflows -->
		<!-- if container doesn't overflow -> set width of element to be 100% in px -->
		<!-- and pass the calcualted width to the ruler to use it in there on the container element -->
		<div
			class="relative h-auto min-w-full w-max timeline-content"
			style="height: {isOverflowingY ? 'auto' : '100%'};"
		>
			<!-- Timeline Ruler -->
			<TimelineRuler amountOfTicks={amountOfTicksRounded}></TimelineRuler>

			<!-- Timeline Thumb-->
			<TimelineThumb></TimelineThumb>

			<!-- Timeline Tracks -->
			<div class="relative flex flex-col pl-5 mb-20 timeline-tracks">
				{#each $timelineTracks as track, i}
					<!-- the dropzone is highlighted automatically if something is hovered over it -->
					{#if i === 0}
						<TimelineRowDivider index={i}></TimelineRowDivider>
						<!-- <div
							class="track-divider w-full bg-slate-500 h-[4px] mt-1 rounded-sm"
							on:drop={(e) => {
								onDropOverDivider(e, i);
							}}
							on:dragleave={(e) => {
								onDropOverDivider(e, i);
							}}
							on:dragenter={onHoverOverDivider}
							on:dragover={onHoverOverDivider}
							></div> -->
						<TimelineRow {track} index={i}></TimelineRow>
						<TimelineRowDivider index={i + 1}></TimelineRowDivider>
					{:else}
						<TimelineRow {track} index={i}></TimelineRow>
						<TimelineRowDivider index={i + 1}></TimelineRowDivider>
					{/if}

					<!-- <div
						class="track-divider w-full bg-slate-500 h-[4px] rounded-sm"
						on:drop={(e) => {
							onDropOverDivider(e, i + 1);
						}}
						on:dragleave={(e) => {
							onDropOverDivider(e, i + 1);
						}}
						on:dragenter={onHoverOverDivider}
						on:dragover={onHoverOverDivider}
					></div> -->
				{/each}

				<!-- <div class="bg-red-700 h-[50px] w-[2200px] mr-5"></div>
				<div class="bg-red-700 h-[50px] w-[800px]"></div>
				<div class="bg-red-700 h-[50px] w-[600px] translate-x-[300px]"></div>
				<div class="bg-red-700 h-[50px] w-[200px] translate-x-[50px]"></div>
				<div class="bg-red-700 h-[50px] w-[300px]"></div>
				<div class="bg-red-700 h-[50px] w-[300px]"></div>
				<div class="bg-red-700 h-[50px] w-[300px]"></div>
				<div class="bg-red-700 h-[50px] w-[300px]"></div>
				<div class="bg-red-700 h-[50px] w-[300px]"></div>
				<div class="bg-red-700 h-[50px] w-[300px]"></div>
				<div class="bg-red-700 h-[50px] w-[300px]"></div>
				<div class="bg-red-700 h-[50px] w-[300px]"></div>
				<div class="bg-red-700 h-[50px] w-[300px]"></div> -->
			</div>
		</div>
	</div>
</div>

<style lang="postcss">
	/* needs to have :global prefix because class gets added dynamically */
	:global(.drag-over) {
		background-color: red;
	}
</style>
